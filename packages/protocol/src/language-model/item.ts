import { SharedProviderMetadata } from "@/provider";
import { JSONValue } from "@/json";
import {
  IN_PROGRESS,
  COMPLETED,
  FAILED,
  INTERRUPTIBLE,
  UNINTERRUPTIBLE,
} from "@/constants";

export type LanguageModelItem = Message | Reasoning | ToolCall | ToolResult;

/**
 * A subset of LanguageModelItem that excludes items that wouldn't
 * make sense for a model to generate (e.g. system/user messages, tool results).
 */
export type LanguageModelResponseItem =
  | AssistantMessage
  | Reasoning
  | ToolCall
  | ToolResult;

export interface SharedBase {
  /**
   * Optional provider-specific metadata for the text part.
   */
  providerMetadata?: SharedProviderMetadata;
}

/**
 * Shared base for language model items.
 */
export interface LanguageModelItemBase extends SharedBase {
  /**
   * A unique identifier for the item. Optional by default.
   */
  id?: string;
}

// ----------------------------
// Content types
// ----------------------------

/**
 * Defines base properties common to all message or artifact parts.
 */
export interface PartBase extends SharedBase {
  /** Optional metadata associated with this part. */
  metadata?: Record<string, unknown>;
}

/**
 * Text that the model has generated.
 */
export interface TextPart extends PartBase {
  readonly kind: "text";

  /**
   * The text content.
   */
  text: string;
}

/**
 * Base properties for file parts.
 */
interface FilePartBase extends PartBase {
  readonly kind: "file";

  /**
   * The IANA media type of the file, e.g. `image/png` or `audio/mp3`.
   *
   * @see https://www.iana.org/assignments/media-types/media-types.xhtml
   */
  mimeType: string;

  /**
   * Optional filename for the file
   */
  filename?: string;
}

/**
 * A file with inline data (base64 string or binary).
 */
export interface FilePartWithData extends FilePartBase {
  /**
   * File data as base64 encoded string or binary data.
   */
  data: string | Uint8Array;

  /**
   * The `uri` property must be absent when `data` is present.
   */
  uri?: never;
}

/**
 * A file referenced by URI.
 */
export interface FilePartWithUri extends FilePartBase {
  /**
   * A URL pointing to the file's content.
   */
  uri: string;

  /**
   * The `data` property must be absent when `uri` is present.
   */
  data?: never;
}

/**
 * A file that has been generated by the model or referenced by URI.
 */
export type FilePart = FilePartWithData | FilePartWithUri;

/**
 * Represents a structured data segment (e.g., JSON) within a message or artifact.
 */
export interface DataPart extends PartBase {
  readonly kind: "data";

  /**
   * The structured data content.
   */
  data: Record<string, unknown>;
}

export type MessagePart = TextPart | FilePart | DataPart;

/**
 * Reasoning that the model has generated.
 */
export interface Reasoning extends LanguageModelItemBase {
  readonly kind: "reasoning";

  /**
   * The reasoning content
   */
  text: string;
}

// ----------------------------
// Message types
// ----------------------------

export interface MessageBase extends SharedBase {
  readonly kind: "message";

  /**
   * The unique identifier for the message.
   */
  id: string;

  /**
   * The content parts of the message.
   */
  content: MessagePart[];

  /**
   * Optional additional metadata for the message
   */
  metadata?: Record<string, unknown>;
}

export interface SystemMessage extends MessageBase {
  /**
   * Representing a system message to the user
   */
  readonly role: "system";
}

export interface AssistantMessage extends MessageBase {
  /**
   * Representing a message from the assistant
   */
  readonly role: "assistant";
}

export interface UserMessage extends MessageBase {
  /**
   * Representing a message from the user
   */
  readonly role: "user";
}

export type Message = SystemMessage | AssistantMessage | UserMessage;

// ----------------------------
// Tool call types
// ----------------------------

/**
 * Tool calls that the model has generated.
 */
export interface ToolCall extends LanguageModelItemBase {
  readonly kind: "tool-call";

  /**
   * The identifier of the tool call. It must be unique across all tool calls.
   */
  callId: string;

  /**
   * The id of the tool that should be called.
   */
  toolId: string;

  /**
   * The state of the tool call.
   */
  state: ToolCallState;

  /**
   * The stringified JSON object with the arguments of the tool call.
   */
  arguments: string;
}

/**
 * Result of a tool call that has been executed by the provider.
 */
export interface ToolResult extends LanguageModelItemBase {
  readonly kind: "tool-result";

  /**
   * The ID of the tool call that this result is associated with.
   */
  callId: string;

  /**
   * Name of the tool that generated this result.
   */
  toolId: string;

  /**
   * The state of the tool call.
   */
  state: ToolCallState;

  /**
   * Result of the tool call. This is a JSON-serializable object.
   */
  result: JSONValue | null;

  /**
   * Error message if the tool call failed
   */
  error: string | null;
}

/**
 * State of a tool call execution.
 */
export type ToolCallState =
  | typeof IN_PROGRESS /* tool is actively executing */
  | typeof COMPLETED /* finished successfully */
  | typeof FAILED /* failed with error */
  | typeof INTERRUPTIBLE /* tool is blocked/waiting and CAN be interrupted  */
  | typeof UNINTERRUPTIBLE; /* tool is blocked/waiting and CANNOT be interrupted (e.g. critical I/O, API call, ..) */
